<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Audio Reactive WebGL Space</title>
  <style>
    :root {
      --bg: #0a0b0f;
      --panel: rgba(10, 12, 18, 0.75);
      --panel-solid: #0c0f18;
      --text: #e9eefc;
      --muted: #aab3c8;
      --accent: #8bd3ff;
      --accent-2: #c2ff9b;
      --danger: #ff7a7a;
      --radius: 14px;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    #app {
      position: fixed;
      inset: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    #ui {
      position: absolute;
      top: env(safe-area-inset-top, 0px);
      left: env(safe-area-inset-left, 0px);
      right: env(safe-area-inset-right, 0px);
      display: flex;
      justify-content: center;
      pointer-events: none;
      padding: 10px 10px 0 10px;
      z-index: 20;
    }

    .panel {
      width: min(960px, 100%);
      background: var(--panel);
      backdrop-filter: blur(10px) saturate(130%);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      pointer-events: auto;
      padding: 12px 14px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px 14px;
      align-items: center;
    }

    .panel .left {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 10px;
      align-items: center;
    }

    .panel .right {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
    }

    .title {
      font-weight: 650;
      font-size: 14px;
      letter-spacing: 0.2px;
      margin-right: 6px;
      color: var(--text);
    }

    .sub {
      font-size: 11px;
      color: var(--muted);
      opacity: 0.9;
    }

    input[type="file"] {
      font-size: 12px;
      color: var(--muted);
      max-width: 220px;
    }

    .btn {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(135deg, rgba(139,211,255,0.14), rgba(194,255,155,0.08));
      color: var(--text);
      padding: 8px 10px;
      font-size: 12px;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 120ms ease, border-color 120ms ease, background 120ms ease;
    }

    .btn:hover { transform: translateY(-1px); border-color: rgba(255,255,255,0.18); }
    .btn:active { transform: translateY(0px) scale(0.98); }

    .btn.secondary {
      background: rgba(255,255,255,0.04);
    }

    .btn.danger {
      background: rgba(255, 122, 122, 0.12);
      border-color: rgba(255, 122, 122, 0.25);
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--muted);
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.07);
      padding: 6px 8px;
      border-radius: 10px;
    }

    .toggle input { accent-color: var(--accent); }

    #hud {
      position: absolute;
      bottom: calc(10px + env(safe-area-inset-bottom, 0px));
      left: calc(10px + env(safe-area-inset-left, 0px));
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 11px;
      color: var(--muted);
      z-index: 15;
      pointer-events: none;
    }

    #joystick {
      position: absolute;
      bottom: calc(18px + env(safe-area-inset-bottom, 0px));
      left: calc(18px + env(safe-area-inset-left, 0px));
      width: 120px;
      height: 120px;
      border-radius: 999px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
      display: none;
      z-index: 16;
      touch-action: none;
    }

    #joystick .stick {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 52px;
      height: 52px;
      margin-left: -26px;
      margin-top: -26px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(139,211,255,0.18), rgba(194,255,155,0.14));
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 6px 16px rgba(0,0,0,0.25);
      pointer-events: none;
      transform: translate(0px, 0px);
    }

    #msg {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      z-index: 30;
      background:
        radial-gradient(circle at 50% 40%, rgba(255,255,255,0.04), transparent 55%),
        linear-gradient(180deg, rgba(0,0,0,0.25), rgba(0,0,0,0.55));
      pointer-events: none;
      opacity: 0;
      transition: opacity 180ms ease;
    }

    #msg.show { opacity: 1; }

    .msg-card {
      width: min(520px, 90vw);
      background: var(--panel-solid);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px 14px 18px;
      text-align: left;
    }

    .msg-card h2 {
      margin: 0 0 6px 0;
      font-size: 18px;
      font-weight: 700;
    }

    .msg-card p {
      margin: 0 0 10px 0;
      font-size: 12.5px;
      color: var(--muted);
      line-height: 1.4;
    }

    .msg-card .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    @media (max-width: 520px) {
      .panel { grid-template-columns: 1fr; }
      .panel .right { justify-content: flex-start; flex-wrap: wrap; }
      input[type="file"] { max-width: 160px; }
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js"
      }
    }
  </script>
</head>
<body>
  <div id="app">
    <div id="ui">
      <div class="panel">
        <div class="left">
          <span class="title">Audio Reactive Space</span>
          <span class="sub">Tap Start Audio to unlock sound. If <b>bsk.mp3</b> is on the server, it will load automatically. You can still load your own file.</span>
          <input id="file" type="file" accept="audio/mpeg,audio/mp3,audio/*" />
          <button id="start" class="btn">Start Audio</button>
          <button id="play" class="btn secondary" disabled>Play</button>
          <button id="pause" class="btn secondary" disabled>Pause</button>
          <button id="stop" class="btn danger" disabled>Stop</button>
        </div>
        <div class="right">
          <label class="toggle"><input id="showHelp" type="checkbox" checked /> HUD</label>
          <label class="toggle"><input id="autoGain" type="checkbox" checked /> Auto Sensitivity</label>
          <label class="toggle"><input id="lowDpr" type="checkbox" /> Battery Saver</label>
        </div>
      </div>
    </div>

    <div id="hud">WASD / Arrow keys to move. Drag to look. On mobile use the joystick and drag right side to look.</div>

    <div id="joystick"><div class="stick"></div></div>

    <div id="msg">
      <div class="msg-card">
        <h2>Default track</h2>
        <p>Tap <b>Start Audio</b> to satisfy browser rules. If <b>bsk.mp3</b> exists next to this HTML on your server, it will load automatically. You can still choose your own MP3.</p>
        <div class="row">
          <span class="sub">Tip: on iOS, keep the silent switch off if you want to hear anything.</span>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";

    // -------------------------
    // Basic setup
    // -------------------------
    const app = document.getElementById("app");
    const fileInput = document.getElementById("file");
    const startBtn = document.getElementById("start");
    const playBtn = document.getElementById("play");
    const pauseBtn = document.getElementById("pause");
    const stopBtn = document.getElementById("stop");
    const hud = document.getElementById("hud");
    const showHelp = document.getElementById("showHelp");
    const autoGainToggle = document.getElementById("autoGain");
    const lowDprToggle = document.getElementById("lowDpr");
    const msg = document.getElementById("msg");
    const joystickEl = document.getElementById("joystick");

    let renderer, scene, camera;
    const clock = new THREE.Clock();

    const isTouch = matchMedia("(pointer: coarse)").matches || "ontouchstart" in window;
    if (isTouch) joystickEl.style.display = "block";

    showHelp.addEventListener("change", () => {
      hud.style.display = showHelp.checked ? "block" : "none";
    });

    lowDprToggle.addEventListener("change", () => {
      if (!renderer) return;
      setRendererDpr();
    });

    function setRendererDpr() {
      const cap = lowDprToggle.checked ? 1.0 : 2.0;
      const dpr = Math.min(window.devicePixelRatio || 1, cap);
      renderer.setPixelRatio(dpr);
    }

    // -------------------------
    // Camera + simple first-person controls (no pointer lock)
    // -------------------------
    const yawPitch = { yaw: 0, pitch: 0 };
    const lookState = { dragging: false, lastX: 0, lastY: 0 };

    const moveState = {
      forward: 0,
      right: 0,
      up: 0,
      speed: 6.0
    };

    const keys = new Set();
    window.addEventListener("keydown", (e) => {
      keys.add(e.code);
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
    }, { passive: false });
    window.addEventListener("keyup", (e) => keys.delete(e.code));

    function updateKeyboardMovement() {
      const f = (keys.has("KeyW") || keys.has("ArrowUp")) ? 1 : 0;
      const b = (keys.has("KeyS") || keys.has("ArrowDown")) ? 1 : 0;
      const r = (keys.has("KeyD") || keys.has("ArrowRight")) ? 1 : 0;
      const l = (keys.has("KeyA") || keys.has("ArrowLeft")) ? 1 : 0;
      const u = keys.has("Space") ? 1 : 0;
      const d = keys.has("ShiftLeft") || keys.has("ShiftRight") ? 1 : 0;

      moveState.forward = f - b;
      moveState.right = r - l;
      moveState.up = u - d;
    }

    // Look controls
    function startLook(x, y) {
      lookState.dragging = true;
      lookState.lastX = x;
      lookState.lastY = y;
    }

    function moveLook(x, y) {
      if (!lookState.dragging) return;
      const dx = x - lookState.lastX;
      const dy = y - lookState.lastY;
      lookState.lastX = x;
      lookState.lastY = y;

      const sensitivity = isTouch ? 0.0045 : 0.003;
      yawPitch.yaw   -= dx * sensitivity;
      yawPitch.pitch -= dy * sensitivity;

      const maxPitch = Math.PI / 2.2;
      yawPitch.pitch = Math.max(-maxPitch, Math.min(maxPitch, yawPitch.pitch));
    }

    function endLook() {
      lookState.dragging = false;
    }

    window.addEventListener("mousedown", (e) => {
      if (e.button !== 0) return;
      const path = e.composedPath ? e.composedPath() : [];
      if (path.some(el => el && el.classList && el.classList.contains("panel"))) return;
      startLook(e.clientX, e.clientY);
    });
    window.addEventListener("mousemove", (e) => moveLook(e.clientX, e.clientY));
    window.addEventListener("mouseup", endLook);

    window.addEventListener("touchstart", (e) => {
      if (!e.touches || e.touches.length === 0) return;
      const t = e.touches[0];
      const target = e.target;
      if (target && target.closest && target.closest(".panel")) return;

      const rightSide = t.clientX > window.innerWidth * 0.45;
      if (rightSide) startLook(t.clientX, t.clientY);
    }, { passive: true });

    window.addEventListener("touchmove", (e) => {
      if (!e.touches || e.touches.length === 0) return;
      const t = e.touches[0];
      if (lookState.dragging) moveLook(t.clientX, t.clientY);
    }, { passive: true });

    window.addEventListener("touchend", endLook);

    // -------------------------
    // On-screen joystick for mobile movement
    // -------------------------
    const joystick = {
      active: false,
      id: null,
      startX: 0,
      startY: 0,
      curX: 0,
      curY: 0,
      maxRadius: 42,
      vec: new THREE.Vector2(0, 0)
    };

    const stickEl = joystickEl.querySelector(".stick");

    function setStickVisual(x, y) {
      stickEl.style.transform = `translate(${x}px, ${y}px)`;
    }

    function resetStick() {
      joystick.vec.set(0, 0);
      setStickVisual(0, 0);
      moveState.forward = 0;
      moveState.right = 0;
    }

    if (isTouch) {
      joystickEl.addEventListener("touchstart", (e) => {
        const t = e.changedTouches[0];
        joystick.active = true;
        joystick.id = t.identifier;
        const rect = joystickEl.getBoundingClientRect();
        joystick.startX = rect.left + rect.width / 2;
        joystick.startY = rect.top + rect.height / 2;
        joystick.curX = t.clientX;
        joystick.curY = t.clientY;
        e.preventDefault();
      }, { passive: false });

      joystickEl.addEventListener("touchmove", (e) => {
        if (!joystick.active) return;
        const t = Array.from(e.changedTouches).find(tt => tt.identifier === joystick.id);
        if (!t) return;

        joystick.curX = t.clientX;
        joystick.curY = t.clientY;

        const dx = joystick.curX - joystick.startX;
        const dy = joystick.curY - joystick.startY;
        const len = Math.hypot(dx, dy);
        const clamped = Math.min(len, joystick.maxRadius);
        const nx = len > 0 ? dx / len : 0;
        const ny = len > 0 ? dy / len : 0;

        const vx = nx * (clamped / joystick.maxRadius);
        const vy = ny * (clamped / joystick.maxRadius);

        joystick.vec.set(vx, vy);
        setStickVisual(vx * joystick.maxRadius, vy * joystick.maxRadius);

        moveState.forward = -joystick.vec.y;
        moveState.right = joystick.vec.x;

        e.preventDefault();
      }, { passive: false });

      joystickEl.addEventListener("touchend", (e) => {
        const ended = Array.from(e.changedTouches).some(tt => tt.identifier === joystick.id);
        if (ended) {
          joystick.active = false;
          joystick.id = null;
          resetStick();
        }
      }, { passive: true });

      joystickEl.addEventListener("touchcancel", () => {
        joystick.active = false;
        joystick.id = null;
        resetStick();
      }, { passive: true });
    }

    // -------------------------
    // Audio setup
    // -------------------------
    const DEFAULT_TRACK = "bsk.mp3";
    let defaultLoadAttempted = false;

    let audioCtx = null;
    let analyser = null;
    let freqData = null;
    let sourceNode = null;
    let audioBuffer = null;
    let isPlaying = false;
    let startedAt = 0;
    let pausedAt = 0;

    const smoothing = 0.85;

    function ensureAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      analyser.smoothingTimeConstant = smoothing;
      freqData = new Uint8Array(analyser.frequencyBinCount);
    }

    function levelBands(data) {
      const n = data.length;
      const lowEnd = Math.floor(n * 0.12);
      const midEnd = Math.floor(n * 0.45);
      const highEnd = Math.floor(n * 0.9);

      let low = 0, mid = 0, high = 0;
      for (let i = 0; i < lowEnd; i++) low += data[i];
      for (let i = lowEnd; i < midEnd; i++) mid += data[i];
      for (let i = midEnd; i < highEnd; i++) high += data[i];

      low /= Math.max(1, lowEnd);
      mid /= Math.max(1, midEnd - lowEnd);
      high /= Math.max(1, highEnd - midEnd);

      return { low: low / 255, mid: mid / 255, high: high / 255 };
    }

    async function loadFile(file) {
      ensureAudio();
      const arrayBuffer = await file.arrayBuffer();
      audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
      pausedAt = 0;
      defaultLoadAttempted = true; // user explicitly chose a file
      updateButtons();
      hideMsg();
    }

    async function loadDefaultTrack() {
      if (defaultLoadAttempted) return;
      defaultLoadAttempted = true;
      try {
        ensureAudio();
        const res = await fetch(DEFAULT_TRACK, { cache: "force-cache" });
        if (!res.ok) throw new Error(`Default track not found (${res.status})`);
        const arrayBuffer = await res.arrayBuffer();
        audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        pausedAt = 0;
        updateButtons();
        hideMsg();
      } catch (err) {
        // If the default isn't present, that's fine. The user can still upload.
        console.warn("Default track failed to load:", err);
      }
    }

    function buildSource(offsetSec = 0) {
      if (!audioBuffer) return null;
      const src = audioCtx.createBufferSource();
      src.buffer = audioBuffer;
      src.connect(analyser);
      analyser.connect(audioCtx.destination);
      src.onended = () => {
        if (isPlaying) {
          isPlaying = false;
          pausedAt = 0;
          updateButtons();
        }
      };
      src.start(0, offsetSec);
      startedAt = audioCtx.currentTime - offsetSec;
      return src;
    }

    async function play() {
      if (!audioBuffer) await loadDefaultTrack();

      if (!audioBuffer) {
        showMsg("No audio loaded. Place bsk.mp3 next to this HTML or choose a file.");
        return;
      }

      ensureAudio();
      if (audioCtx.state === "suspended") await audioCtx.resume();
      if (isPlaying) return;

      sourceNode = buildSource(pausedAt);
      if (!sourceNode) return;
      isPlaying = true;
      updateButtons();
    }

    function pause() {
      if (!isPlaying || !sourceNode) return;
      const elapsed = audioCtx.currentTime - startedAt;
      pausedAt = Math.min(elapsed, audioBuffer ? audioBuffer.duration : elapsed);
      try { sourceNode.stop(); } catch {}
      sourceNode.disconnect();
      sourceNode = null;
      isPlaying = false;
      updateButtons();
    }

    function stop() {
      if (sourceNode) {
        try { sourceNode.stop(); } catch {}
        sourceNode.disconnect();
        sourceNode = null;
      }
      isPlaying = false;
      pausedAt = 0;
      updateButtons();
    }

    function updateButtons() {
      const hasAudio = !!audioBuffer;
      playBtn.disabled = !hasAudio || isPlaying;
      pauseBtn.disabled = !hasAudio || !isPlaying;
      stopBtn.disabled = !hasAudio && !isPlaying;
    }

    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      try {
        await loadFile(file);
      } catch (err) {
        console.error(err);
        showMsg("Could not decode audio. Try a different MP3.");
      }
    });

    startBtn.addEventListener("click", async () => {
      ensureAudio();
      if (audioCtx.state === "suspended") await audioCtx.resume();

      if (!renderer) initThree();

      if (!audioBuffer) await loadDefaultTrack();

      updateButtons();
      hideMsg();
    });

    playBtn.addEventListener("click", play);
    pauseBtn.addEventListener("click", pause);
    stopBtn.addEventListener("click", stop);

    // -------------------------
    // Message overlay helpers
    // -------------------------
    function showMsg(customText) {
      const card = msg.querySelector(".msg-card p");
      if (customText) card.innerHTML = customText;
      msg.classList.add("show");
    }

    function hideMsg() {
      msg.classList.remove("show");
    }

    showMsg("Tap <b>Start Audio</b>. The app will try to load <b>bsk.mp3</b> from the server automatically.");

    // -------------------------
    // Three.js scene content
    // -------------------------
    let lowCore, midSwarm, highSparks, floorGrid, nebula, stars;

    let autoGain = 1.0;
    let peakTracker = 0.0001;

    function initThree() {
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
      setRendererDpr();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x05060b, 1);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      app.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x05060b, 0.018);

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 200);
      camera.position.set(0, 1.6, 6);

      const amb = new THREE.AmbientLight(0xffffff, 0.35);
      scene.add(amb);
      const dir = new THREE.DirectionalLight(0xbdd7ff, 0.9);
      dir.position.set(6, 10, 4);
      scene.add(dir);

      const gridGeo = new THREE.PlaneGeometry(140, 140, 70, 70);
      const gridMat = new THREE.MeshStandardMaterial({
        color: 0x0b0f1d,
        roughness: 0.8,
        metalness: 0.0,
        emissive: 0x0b1630,
        emissiveIntensity: 0.15,
        transparent: true,
        opacity: 0.95
      });
      floorGrid = new THREE.Mesh(gridGeo, gridMat);
      floorGrid.rotation.x = -Math.PI / 2;
      floorGrid.position.y = 0;
      scene.add(floorGrid);

      const lowGeo = new THREE.IcosahedronGeometry(1.2, 3);
      const lowMat = new THREE.MeshStandardMaterial({
        color: 0x0e1227,
        roughness: 0.25,
        metalness: 0.6,
        emissive: 0x1b3c7a,
        emissiveIntensity: 0.35
      });
      lowCore = new THREE.Mesh(lowGeo, lowMat);
      lowCore.position.set(0, 1.7, -2.5);
      scene.add(lowCore);

      midSwarm = new THREE.Group();
      const midGeo = new THREE.BoxGeometry(0.22, 0.22, 0.22);
      for (let i = 0; i < 120; i++) {
        const mat = new THREE.MeshStandardMaterial({
          color: 0x101a2e,
          roughness: 0.35,
          metalness: 0.35,
          emissive: 0x163a2a,
          emissiveIntensity: 0.15
        });
        const m = new THREE.Mesh(midGeo, mat);
        const radius = 2.2 + Math.random() * 4.0;
        const angle = Math.random() * Math.PI * 2;
        const height = 0.4 + Math.random() * 2.6;
        m.position.set(Math.cos(angle) * radius, height, Math.sin(angle) * radius - 2.5);
        m.userData = { radius, angle, height, spin: (Math.random() - 0.5) * 0.02, wobble: Math.random() * 10 };
        midSwarm.add(m);
      }
      scene.add(midSwarm);

      const sparkCount = 2200;
      const sparkPositions = new Float32Array(sparkCount * 3);
      const sparkSizes = new Float32Array(sparkCount);
      for (let i = 0; i < sparkCount; i++) {
        const r = 6 + Math.random() * 18;
        const a = Math.random() * Math.PI * 2;
        const y = 0.5 + Math.random() * 7.5;
        sparkPositions[i*3] = Math.cos(a) * r;
        sparkPositions[i*3 + 1] = y;
        sparkPositions[i*3 + 2] = Math.sin(a) * r - 6;
        sparkSizes[i] = 1.0;
      }
      const sparkGeo = new THREE.BufferGeometry();
      sparkGeo.setAttribute("position", new THREE.BufferAttribute(sparkPositions, 3));
      sparkGeo.setAttribute("size", new THREE.BufferAttribute(sparkSizes, 1));

      const sparkMat = new THREE.PointsMaterial({
        color: 0xb6d8ff,
        size: 0.035,
        transparent: true,
        opacity: 0.75,
        depthWrite: false
      });
      highSparks = new THREE.Points(sparkGeo, sparkMat);
      scene.add(highSparks);

      const ringGeo = new THREE.TorusKnotGeometry(1.8, 0.28, 180, 22);
      const ringMat = new THREE.MeshStandardMaterial({
        color: 0x0d0f20,
        roughness: 0.2,
        metalness: 0.85,
        emissive: 0x2b1f6b,
        emissiveIntensity: 0.25
      });
      nebula = new THREE.Mesh(ringGeo, ringMat);
      nebula.position.set(0, 2.9, -5.5);
      scene.add(nebula);

      const starCount = 3000;
      const starPos = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
        const radius = 40 + Math.random() * 90;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        starPos[i*3] = radius * Math.sin(phi) * Math.cos(theta);
        starPos[i*3 + 1] = radius * Math.cos(phi);
        starPos[i*3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
      }
      const starGeo = new THREE.BufferGeometry();
      starGeo.setAttribute("position", new THREE.BufferAttribute(starPos, 3));
      const starMat = new THREE.PointsMaterial({
        color: 0x9bb1d8,
        size: 0.06,
        transparent: true,
        opacity: 0.55,
        depthWrite: false
      });
      stars = new THREE.Points(starGeo, starMat);
      scene.add(stars);

      window.addEventListener("resize", onResize);

      clock.start();
      animate();
    }

    function onResize() {
      if (!renderer || !camera) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function applyAutoGain(bands) {
      if (!autoGainToggle.checked) return { ...bands, gain: 1.0 };

      const energy = (bands.low + bands.mid + bands.high) / 3;
      peakTracker = Math.max(peakTracker * 0.995, energy);
      const targetGain = peakTracker > 0 ? 0.55 / peakTracker : 1.0;
      autoGain = THREE.MathUtils.lerp(autoGain, targetGain, 0.08);

      return {
        low: THREE.MathUtils.clamp(bands.low * autoGain, 0, 1.2),
        mid: THREE.MathUtils.clamp(bands.mid * autoGain, 0, 1.2),
        high: THREE.MathUtils.clamp(bands.high * autoGain, 0, 1.2),
        gain: autoGain
      };
    }

    // -------------------------
    // Movement update
    // -------------------------
    const tmpVec3 = new THREE.Vector3();
    const forwardVec = new THREE.Vector3();
    const rightVec = new THREE.Vector3();

    function updateCamera(dt) {
      if (!isTouch || !joystick.active) updateKeyboardMovement();

      const euler = new THREE.Euler(yawPitch.pitch, yawPitch.yaw, 0, "YXZ");
      camera.quaternion.setFromEuler(euler);

      forwardVec.set(0, 0, -1).applyAxisAngle(new THREE.Vector3(0,1,0), yawPitch.yaw);
      rightVec.set(1, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), yawPitch.yaw);

      tmpVec3.set(0, 0, 0);
      tmpVec3.addScaledVector(forwardVec, moveState.forward);
      tmpVec3.addScaledVector(rightVec, moveState.right);
      tmpVec3.y += moveState.up * 0.65;

      if (tmpVec3.lengthSq() > 0) tmpVec3.normalize();

      const speed = moveState.speed * (isPlaying ? 1.05 : 1.0);
      camera.position.addScaledVector(tmpVec3, speed * dt);

      camera.position.y = Math.max(1.15, camera.position.y);

      const bound = 55;
      camera.position.x = THREE.MathUtils.clamp(camera.position.x, -bound, bound);
      camera.position.z = THREE.MathUtils.clamp(camera.position.z, -bound, bound);
    }

    // -------------------------
    // Animation loop
    // -------------------------
    function animate() {
      requestAnimationFrame(animate);
      if (!renderer || !scene || !camera) return;

      const dt = Math.min(0.033, clock.getDelta());

      let bands = { low: 0, mid: 0, high: 0, gain: 1 };
      if (analyser && freqData) {
        analyser.getByteFrequencyData(freqData);
        bands = applyAutoGain(levelBands(freqData));
      }

      updateCamera(dt);
      updateWorld(dt, bands);

      renderer.render(scene, camera);
    }

    function updateWorld(dt, bands) {
      const t = clock.elapsedTime;

      if (stars) stars.rotation.y += dt * 0.01;

      if (lowCore) {
        const lowPulse = 1 + bands.low * 0.55 + Math.sin(t * 1.2) * 0.03;
        lowCore.scale.setScalar(lowPulse);
        lowCore.rotation.y += dt * (0.15 + bands.low * 0.9);
        lowCore.material.emissiveIntensity = 0.25 + bands.low * 1.1;
      }

      if (floorGrid) {
        floorGrid.material.emissiveIntensity = 0.08 + bands.low * 0.55;
        floorGrid.material.opacity = 0.85 + bands.low * 0.12;
      }

      if (midSwarm) {
        const midSpeed = 0.35 + bands.mid * 1.6;
        midSwarm.children.forEach((m) => {
          const ud = m.userData;
          ud.angle += dt * midSpeed * (0.35 + ud.spin * 10);
          const wobble = Math.sin(t * 1.1 + ud.wobble) * 0.12 * (0.2 + bands.mid);
          const radius = ud.radius + wobble;
          m.position.x = Math.cos(ud.angle) * radius;
          m.position.z = Math.sin(ud.angle) * radius - 2.5;
          m.position.y = ud.height + Math.sin(t * 0.8 + ud.wobble) * 0.08 * (0.4 + bands.mid);
          m.rotation.x += dt * (0.4 + bands.mid * 2.0);
          m.rotation.y += dt * (0.2 + bands.mid * 1.5);
          m.material.emissiveIntensity = 0.06 + bands.mid * 0.55;
        });
      }

      if (highSparks) {
        highSparks.rotation.y -= dt * (0.08 + bands.high * 0.55);
        highSparks.material.opacity = 0.35 + bands.high * 0.75;
        highSparks.material.size = 0.02 + bands.high * 0.07;
      }

      if (nebula) {
        const full = (bands.low + bands.mid + bands.high) / 3;
        nebula.rotation.x += dt * (0.08 + bands.mid * 0.35);
        nebula.rotation.y -= dt * (0.12 + bands.high * 0.4);
        nebula.scale.setScalar(1 + full * 0.45);
        nebula.material.emissiveIntensity = 0.18 + full * 0.9;
      }

      if (camera && lowCore) {
        const camZ = camera.position.z;
        lowCore.position.z = -2.5 + Math.sin(t * 0.4) * 0.08 + (camZ * 0.002);
      }

      if (nebula) {
        nebula.position.x = Math.sin(t * 0.25) * 0.3;
      }

      if (!audioBuffer && lowCore && nebula) {
        lowCore.material.emissiveIntensity = 0.22 + Math.sin(t * 1.1) * 0.04;
        nebula.material.emissiveIntensity = 0.18 + Math.sin(t * 0.7) * 0.03;
      }
    }

    // Boot visuals before audio if user taps canvas
    window.addEventListener("pointerdown", (e) => {
      const target = e.target;
      if (target && target.closest && target.closest(".panel")) return;
      if (!renderer) initThree();
    }, { passive: true });

    updateButtons();

    console.log("Audio Reactive Space ready. Put bsk.mp3 next to this HTML for auto-load.");
  </script>
</body>
</html>
